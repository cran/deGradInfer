<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">

<head>

<meta charset="utf-8" />
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="pandoc" />

<meta name="viewport" content="width=device-width, initial-scale=1">

<meta name="author" content="Benn Macdonald and Frank Dondelinger" />

<meta name="date" content="2017-12-05" />

<title>ODE parameter inference with deGradInfer</title>



<style type="text/css">code{white-space: pre;}</style>
<style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
</style>



<link href="data:text/css;charset=utf-8,body%20%7B%0Abackground%2Dcolor%3A%20%23fff%3B%0Amargin%3A%201em%20auto%3B%0Amax%2Dwidth%3A%20700px%3B%0Aoverflow%3A%20visible%3B%0Apadding%2Dleft%3A%202em%3B%0Apadding%2Dright%3A%202em%3B%0Afont%2Dfamily%3A%20%22Open%20Sans%22%2C%20%22Helvetica%20Neue%22%2C%20Helvetica%2C%20Arial%2C%20sans%2Dserif%3B%0Afont%2Dsize%3A%2014px%3B%0Aline%2Dheight%3A%201%2E35%3B%0A%7D%0A%23header%20%7B%0Atext%2Dalign%3A%20center%3B%0A%7D%0A%23TOC%20%7B%0Aclear%3A%20both%3B%0Amargin%3A%200%200%2010px%2010px%3B%0Apadding%3A%204px%3B%0Awidth%3A%20400px%3B%0Aborder%3A%201px%20solid%20%23CCCCCC%3B%0Aborder%2Dradius%3A%205px%3B%0Abackground%2Dcolor%3A%20%23f6f6f6%3B%0Afont%2Dsize%3A%2013px%3B%0Aline%2Dheight%3A%201%2E3%3B%0A%7D%0A%23TOC%20%2Etoctitle%20%7B%0Afont%2Dweight%3A%20bold%3B%0Afont%2Dsize%3A%2015px%3B%0Amargin%2Dleft%3A%205px%3B%0A%7D%0A%23TOC%20ul%20%7B%0Apadding%2Dleft%3A%2040px%3B%0Amargin%2Dleft%3A%20%2D1%2E5em%3B%0Amargin%2Dtop%3A%205px%3B%0Amargin%2Dbottom%3A%205px%3B%0A%7D%0A%23TOC%20ul%20ul%20%7B%0Amargin%2Dleft%3A%20%2D2em%3B%0A%7D%0A%23TOC%20li%20%7B%0Aline%2Dheight%3A%2016px%3B%0A%7D%0Atable%20%7B%0Amargin%3A%201em%20auto%3B%0Aborder%2Dwidth%3A%201px%3B%0Aborder%2Dcolor%3A%20%23DDDDDD%3B%0Aborder%2Dstyle%3A%20outset%3B%0Aborder%2Dcollapse%3A%20collapse%3B%0A%7D%0Atable%20th%20%7B%0Aborder%2Dwidth%3A%202px%3B%0Apadding%3A%205px%3B%0Aborder%2Dstyle%3A%20inset%3B%0A%7D%0Atable%20td%20%7B%0Aborder%2Dwidth%3A%201px%3B%0Aborder%2Dstyle%3A%20inset%3B%0Aline%2Dheight%3A%2018px%3B%0Apadding%3A%205px%205px%3B%0A%7D%0Atable%2C%20table%20th%2C%20table%20td%20%7B%0Aborder%2Dleft%2Dstyle%3A%20none%3B%0Aborder%2Dright%2Dstyle%3A%20none%3B%0A%7D%0Atable%20thead%2C%20table%20tr%2Eeven%20%7B%0Abackground%2Dcolor%3A%20%23f7f7f7%3B%0A%7D%0Ap%20%7B%0Amargin%3A%200%2E5em%200%3B%0A%7D%0Ablockquote%20%7B%0Abackground%2Dcolor%3A%20%23f6f6f6%3B%0Apadding%3A%200%2E25em%200%2E75em%3B%0A%7D%0Ahr%20%7B%0Aborder%2Dstyle%3A%20solid%3B%0Aborder%3A%20none%3B%0Aborder%2Dtop%3A%201px%20solid%20%23777%3B%0Amargin%3A%2028px%200%3B%0A%7D%0Adl%20%7B%0Amargin%2Dleft%3A%200%3B%0A%7D%0Adl%20dd%20%7B%0Amargin%2Dbottom%3A%2013px%3B%0Amargin%2Dleft%3A%2013px%3B%0A%7D%0Adl%20dt%20%7B%0Afont%2Dweight%3A%20bold%3B%0A%7D%0Aul%20%7B%0Amargin%2Dtop%3A%200%3B%0A%7D%0Aul%20li%20%7B%0Alist%2Dstyle%3A%20circle%20outside%3B%0A%7D%0Aul%20ul%20%7B%0Amargin%2Dbottom%3A%200%3B%0A%7D%0Apre%2C%20code%20%7B%0Abackground%2Dcolor%3A%20%23f7f7f7%3B%0Aborder%2Dradius%3A%203px%3B%0Acolor%3A%20%23333%3B%0Awhite%2Dspace%3A%20pre%2Dwrap%3B%20%0A%7D%0Apre%20%7B%0Aborder%2Dradius%3A%203px%3B%0Amargin%3A%205px%200px%2010px%200px%3B%0Apadding%3A%2010px%3B%0A%7D%0Apre%3Anot%28%5Bclass%5D%29%20%7B%0Abackground%2Dcolor%3A%20%23f7f7f7%3B%0A%7D%0Acode%20%7B%0Afont%2Dfamily%3A%20Consolas%2C%20Monaco%2C%20%27Courier%20New%27%2C%20monospace%3B%0Afont%2Dsize%3A%2085%25%3B%0A%7D%0Ap%20%3E%20code%2C%20li%20%3E%20code%20%7B%0Apadding%3A%202px%200px%3B%0A%7D%0Adiv%2Efigure%20%7B%0Atext%2Dalign%3A%20center%3B%0A%7D%0Aimg%20%7B%0Abackground%2Dcolor%3A%20%23FFFFFF%3B%0Apadding%3A%202px%3B%0Aborder%3A%201px%20solid%20%23DDDDDD%3B%0Aborder%2Dradius%3A%203px%3B%0Aborder%3A%201px%20solid%20%23CCCCCC%3B%0Amargin%3A%200%205px%3B%0A%7D%0Ah1%20%7B%0Amargin%2Dtop%3A%200%3B%0Afont%2Dsize%3A%2035px%3B%0Aline%2Dheight%3A%2040px%3B%0A%7D%0Ah2%20%7B%0Aborder%2Dbottom%3A%204px%20solid%20%23f7f7f7%3B%0Apadding%2Dtop%3A%2010px%3B%0Apadding%2Dbottom%3A%202px%3B%0Afont%2Dsize%3A%20145%25%3B%0A%7D%0Ah3%20%7B%0Aborder%2Dbottom%3A%202px%20solid%20%23f7f7f7%3B%0Apadding%2Dtop%3A%2010px%3B%0Afont%2Dsize%3A%20120%25%3B%0A%7D%0Ah4%20%7B%0Aborder%2Dbottom%3A%201px%20solid%20%23f7f7f7%3B%0Amargin%2Dleft%3A%208px%3B%0Afont%2Dsize%3A%20105%25%3B%0A%7D%0Ah5%2C%20h6%20%7B%0Aborder%2Dbottom%3A%201px%20solid%20%23ccc%3B%0Afont%2Dsize%3A%20105%25%3B%0A%7D%0Aa%20%7B%0Acolor%3A%20%230033dd%3B%0Atext%2Ddecoration%3A%20none%3B%0A%7D%0Aa%3Ahover%20%7B%0Acolor%3A%20%236666ff%3B%20%7D%0Aa%3Avisited%20%7B%0Acolor%3A%20%23800080%3B%20%7D%0Aa%3Avisited%3Ahover%20%7B%0Acolor%3A%20%23BB00BB%3B%20%7D%0Aa%5Bhref%5E%3D%22http%3A%22%5D%20%7B%0Atext%2Ddecoration%3A%20underline%3B%20%7D%0Aa%5Bhref%5E%3D%22https%3A%22%5D%20%7B%0Atext%2Ddecoration%3A%20underline%3B%20%7D%0A%0Acode%20%3E%20span%2Ekw%20%7B%20color%3A%20%23555%3B%20font%2Dweight%3A%20bold%3B%20%7D%20%0Acode%20%3E%20span%2Edt%20%7B%20color%3A%20%23902000%3B%20%7D%20%0Acode%20%3E%20span%2Edv%20%7B%20color%3A%20%2340a070%3B%20%7D%20%0Acode%20%3E%20span%2Ebn%20%7B%20color%3A%20%23d14%3B%20%7D%20%0Acode%20%3E%20span%2Efl%20%7B%20color%3A%20%23d14%3B%20%7D%20%0Acode%20%3E%20span%2Ech%20%7B%20color%3A%20%23d14%3B%20%7D%20%0Acode%20%3E%20span%2Est%20%7B%20color%3A%20%23d14%3B%20%7D%20%0Acode%20%3E%20span%2Eco%20%7B%20color%3A%20%23888888%3B%20font%2Dstyle%3A%20italic%3B%20%7D%20%0Acode%20%3E%20span%2Eot%20%7B%20color%3A%20%23007020%3B%20%7D%20%0Acode%20%3E%20span%2Eal%20%7B%20color%3A%20%23ff0000%3B%20font%2Dweight%3A%20bold%3B%20%7D%20%0Acode%20%3E%20span%2Efu%20%7B%20color%3A%20%23900%3B%20font%2Dweight%3A%20bold%3B%20%7D%20%20code%20%3E%20span%2Eer%20%7B%20color%3A%20%23a61717%3B%20background%2Dcolor%3A%20%23e3d2d2%3B%20%7D%20%0A" rel="stylesheet" type="text/css" />

</head>

<body>




<h1 class="title toc-ignore">ODE parameter inference with deGradInfer</h1>
<h4 class="author"><em>Benn Macdonald and Frank Dondelinger</em></h4>
<h4 class="date"><em>2017-12-05</em></h4>



<p>The package <code>deGradInfer</code> is an R package for efficient parameter inference in systems of ordinary differential equations (ODEs), using adaptive gradient matching via Gaussian processes. This implementation follows from the work in <span class="citation">Calderhead et al. (2009)</span>; <span class="citation">Dondelinger et al. (2013)</span> and <span class="citation">Macdonald (2017)</span>, although the software has been extended with several crucial features to make it robust and useful for practical applications. Features include:</p>
<ul>
<li>Specifying custom ODE systems as R functions.</li>
<li>Dealing with missing/unobserved variables.</li>
<li>Visualization for monitoring MCMC run evolution.</li>
<li>Specification of tolerable mismatch between data and inferred ODE dynamics.</li>
</ul>
<p>In the next section, we will briefly sketch the underlying statistical model and inference, before moving on to the practical examples of how to use the package.</p>
<div id="model-and-inference" class="section level1">
<h1>Model and Inference</h1>
<p>The package implements the adaptive gradient matching approach of <span class="citation">Dondelinger et al. (2013)</span>, with the option of using parallel tempering to fix the mismatch parameter in place, as described in <span class="citation">Macdonald (2017)</span>. The advantage of gradient matching as a parameter inference technique is that it does not require us to numerically solve the ODE system at each step, a potentially costly operation for large systems.</p>
<p>Briefly, assuming Gaussian noise on the observed variable <span class="math inline">\(\mathbf{y}_k\)</span>, <span class="math inline">\(P(y_k(t)) = \mathcal{N}(y_k(t)|x_k(t),\sigma_k)\)</span>, we can model the latent variables <span class="math inline">\(\mathbf{x}_k\)</span> using a Gaussian process prior:</p>
<p><span class="math display">\[P(\mathbf{x}_k|\Psi_k) = \mathcal{N}(\mathbf{x}_k|\mathbf{0}, \mathbf{C}_{\Psi_k}),\]</span> where <span class="math inline">\(\mathbf{C}_{\Psi_k}\)</span> denotes a positive definite matrix of covariance functions with hyperparameters <span class="math inline">\(\Psi_k\)</span>. We can use the properties of Gaussian processes to obtain a model (in closed form) for the gradient <span class="math inline">\(\mathbf{\dot{x}}_k\)</span>, which we combine with the ODE system model via a product of experts:</p>
<p><span class="math display">\[P(\mathbf{\dot{x}}_k|\mathbf{X},\Theta,\Psi_k,\gamma_k) \propto P(\mathbf{\dot{x}}_k|\mathbf{x}_k,\Psi_k)P(\mathbf{\dot{x}}_k|\mathbf{X},\Theta,\gamma_k),\]</span> where <span class="math inline">\(\mathbf{X}\)</span> is a <span class="math inline">\(T \times K\)</span> matrix where column <span class="math inline">\(k\)</span> corresponds to <span class="math inline">\(\mathbf{x}_k\)</span>. Note that this approach essentially provides two models for <span class="math inline">\(\mathbf{\dot{x}}_k\)</span>; a Gaussian process model which is based on a smoothing of the observed variables, and the ODE model, with parameters <span class="math inline">\(\Theta\)</span>. The parameters <span class="math inline">\(\gamma_k\)</span> allow for some Gaussian noise on the ODE estimates of the gradients, and thus effectively control the allowable mismatch between the ODE and Gaussian process estimates.</p>
<p>Rather than inferring the gradient mismatch parameters, we can instead use parallel tempering to set them. If the ODE model properly (or adequately) describes the process then ideally we would want no (or little) mismatch between the predctions from the ODEs and the interpolant, when sampling from the posterior. However, bringing in this knowledge by forcing there to be no mismatch between the gradients at the beginning of the MCMC run can cause the algorithm to converge to suboptimal states. Instead, by running a number of parallel chains, setting large values of the gradient mismatch parameter for chains closer to the prior and small values for chains closer to the posterior, this prior knowledge can be brought in whilst still allowing the algorithm enough flexibility to explore. See <span class="citation">Macdonald (2017)</span> for details.</p>
<p>We integrate out the latent variables <span class="math inline">\(\mathbf{\dot{X}}\)</span> and do inference over the joint model <span class="math inline">\(P(\mathbf{Y}, \mathbf{X}, \mathbf{\Theta}, \mathbf{\Psi}, \mathbf{\sigma})\)</span> (see <span class="citation">Dondelinger et al. (2013)</span> for details). Inference is done using population MCMC, which can deal with multimodal posterior landscapes, and will give a posterior distribution for the parameters, in addition to the posterior mean estimates.</p>
</div>
<div id="correct-format-for-a-user-specified-prior" class="section level1">
<h1>Correct format for a user specified prior</h1>
<p>The package supports priors defined by the user. The user should write their function to return a vector of log densities, for a given parameter set. For example, a Uniform prior (lowerbound=0, upperbound=10) on parameter 1, a Gamma prior (shape=4, scale=0.5) on parameters 2 and 3 and a Chi-squared prior (degrees of freedom=2) on parameter 4 would take the form</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">testLogPrior &lt;-<span class="st"> </span>function(params)
{
    <span class="kw">return</span>(<span class="kw">c</span>(<span class="kw">dunif</span>(params[<span class="dv">1</span>],<span class="dv">0</span>,<span class="dv">10</span>,<span class="dt">log=</span><span class="ot">TRUE</span>),
        <span class="kw">dgamma</span>(params[<span class="dv">2</span>:<span class="dv">3</span>],<span class="dt">shape=</span><span class="dv">4</span>,<span class="dt">scale=</span><span class="fl">0.5</span>,<span class="dt">log=</span><span class="ot">TRUE</span>),
        <span class="kw">dchisq</span>(params[<span class="dv">4</span>],<span class="dv">2</span>,<span class="dt">log=</span><span class="ot">TRUE</span>)))
}</code></pre></div>
</div>
<div id="specifying-ode-systems-as-r-functions" class="section level1">
<h1>Specifying ODE systems as R functions</h1>
<p>We will use the example of a simple Lotka-Volterra prey-predator system. This consists of two variables representing a predator species and a prey species. The system is governed by four parameters and takes the following form:</p>
<p><span class="math display">\[
\frac{dx_1}{dt} =  x_1 (a - b x_2) \hspace{1cm}\mathrm{Prey} \\
\frac{dx_2}{dt} = -x_2 (c x_2 - d x_1) \hspace{1cm}\mathrm{Predators}
\]</span></p>
<p>where <span class="math inline">\(x_1\)</span> represents the number of prey and <span class="math inline">\(x_2\)</span> represents the number of predators.</p>
<p>In order to use <code>deGradInfer</code>, we need to represent this system as an R function. Our implementation is inspired by the package <code>deSolve</code> for numerically solving ODE systems represented as R functions. In particular, we require the function to be of the form <code>func &lt;- function(t,X,params,...)</code> where <code>t</code> is a <span class="math inline">\(T\)</span>-dimensional vector of time points, <code>X</code> is a <span class="math inline">\(T \times K\)</span> matrix containing the values for the <span class="math inline">\(K\)</span> variables in the system, <code>params</code> is a <span class="math inline">\(p\)</span>-dimensional vector of parameters, and <code>...</code> denotes optional parameters that may be passed to the function. The output should be a <span class="math inline">\(T \times K\)</span> matrix of the gradients <span class="math inline">\(\frac{dx_k}{dt}\)</span> for all variables <span class="math inline">\(k\)</span>. For the Lotka-Volterra system, we can define an R function as:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">LV_func &lt;-<span class="st"> </span>function(t, X, params) {
    dxdt =<span class="st"> </span><span class="kw">cbind</span>(
      X[,<span class="dv">1</span>]*(params[<span class="dv">1</span>] -<span class="st"> </span>params[<span class="dv">2</span>]*X[,<span class="dv">2</span>]), <span class="co"># Prey</span>
    -<span class="st"> </span>X[,<span class="dv">2</span>]*(params[<span class="dv">3</span>] -<span class="st"> </span>params[<span class="dv">4</span>]*X[,<span class="dv">1</span>])  <span class="co"># Predators</span>
    )
    <span class="kw">return</span>(dxdt)
}</code></pre></div>
<p>Note that if one wishes to use their function with <code>deSolve</code>, it needs to be compatible with scalar <code>t</code>, and additionally needs to return a list (this is a requirement by <code>deSolve</code> to allow for returning global values that are needed at each time point; we do not currently return any such global values). This is best achieved by writing a wrapper for the function:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(<span class="st">'deSolve'</span>)

<span class="co"># Wrapper function</span>
deSolve_LV_func =<span class="st"> </span>function(t,y,params) {
  <span class="kw">list</span>(<span class="kw">LV_func</span>(t,<span class="kw">matrix</span>(y,<span class="dv">1</span>,<span class="kw">length</span>(y)),params))
}

<span class="co"># Generate some data</span>
test.times =<span class="st"> </span><span class="kw">seq</span>(<span class="dv">0</span>,<span class="dv">2</span>,<span class="fl">0.1</span>)
test.data =<span class="st"> </span><span class="kw">ode</span>(<span class="kw">c</span>(<span class="dv">5</span>,<span class="dv">3</span>), test.times, deSolve_LV_func, <span class="kw">c</span>(<span class="dv">2</span>,<span class="dv">1</span>,<span class="dv">4</span>,<span class="dv">1</span>))
test.data =<span class="st"> </span>test.data[,<span class="dv">2</span>:<span class="dv">3</span>] +
<span class="st">  </span><span class="kw">rnorm</span>(<span class="kw">dim</span>(test.data)[<span class="dv">1</span>]*<span class="dv">2</span>,<span class="dv">0</span>,<span class="fl">0.1</span>) <span class="co"># add some observational noise</span></code></pre></div>
</div>
<div id="parameter-inference-in-the-lotka-volterra-system" class="section level1">
<h1>Parameter inference in the Lotka-Volterra system</h1>
<p>The main interface to the package is provided via the <code>agm</code> function. The user needs to provide the data for the observed time points, the R function representing the ODE system, the number of parameters in the system, and the expected standard deviation of the observational noise. Note that we do not currently allow the noise to be inferred for the gradient matching approach, as this tends to overestimate the true noise in the data.</p>
<p>Here we only run the model for 1000 iterations, which is not sufficient to reach convergence, but is good enough for demonstration purposes:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(<span class="st">'deGradInfer'</span>)

agm.result =<span class="st"> </span><span class="kw">agm</span>(test.data,test.times,LV_func,<span class="dv">4</span>,<span class="dt">noise.sd=</span><span class="fl">0.1</span>,
                 <span class="dt">maxIterations=</span><span class="dv">1000</span>,<span class="dt">chainNum=</span><span class="dv">5</span>)

<span class="kw">print</span>(agm.result$posterior.mean)</code></pre></div>
<pre><code>## [1] 1.5969013 0.8912932 2.2307739 0.7232515</code></pre>
<p>We can plot the posterior distribution of the inferred parameter values using the samples from the posterior.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(<span class="st">'ggplot2'</span>)

plotting.frame =<span class="st"> </span><span class="kw">data.frame</span>(<span class="dt">Param.Values=</span><span class="kw">c</span>(agm.result$posterior.samples), 
                            <span class="dt">Param.Num=</span><span class="kw">rep</span>(<span class="dv">1</span>:<span class="dv">4</span>, <span class="dt">each=</span><span class="kw">dim</span>(agm.result$posterior.samples)[<span class="dv">1</span>]))

<span class="kw">ggplot</span>(plotting.frame, <span class="kw">aes</span>(<span class="dt">x=</span>Param.Values, <span class="dt">y=</span>..scaled..)) +
<span class="st">  </span><span class="kw">facet_wrap</span>(~<span class="kw">paste</span>(<span class="st">'Parameter'</span>, Param.Num), <span class="dt">scales =</span> <span class="st">'free'</span>) +<span class="st"> </span>
<span class="st">  </span><span class="kw">geom_density</span>() +
<span class="st">  </span><span class="kw">labs</span>(<span class="dt">y=</span><span class="st">'Scaled Density'</span>, <span class="dt">x=</span><span class="st">'Parameter Value'</span>) +<span class="st"> </span>
<span class="st">  </span><span class="kw">xlim</span>(<span class="kw">c</span>(<span class="dv">0</span>,<span class="dv">5</span>))</code></pre></div>
<p><img src="data:image/png;base64,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" /><!-- --></p>
<p>We can also inspect the evolution of the log likelihood:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">qplot</span>(<span class="dt">x=</span><span class="kw">seq</span>(<span class="dv">25</span>,<span class="dv">1000</span>,<span class="dv">25</span>), <span class="dt">y=</span><span class="kw">c</span>(agm.result$ll), <span class="dt">geom =</span> <span class="st">'line'</span>) +<span class="st"> </span>
<span class="st">  </span><span class="kw">labs</span>(<span class="dt">x=</span><span class="st">'Iterations'</span>, <span class="dt">y=</span><span class="st">'Log-likelihood'</span>)</code></pre></div>
<p><img src="data:image/png;base64,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" /><!-- --></p>
<div id="tempering-the-mismatch-parameter" class="section level2">
<h2>Tempering the mismatch parameter</h2>
<p>The mismatch between the Gaussian process model and the ODE model of the system is captured by the parameter <span class="math inline">\(\gamma\)</span>. <span class="citation">Macdonald (2017)</span> introduced a tempering scheme to replace naive inference of this parameter. This scheme can be used in our model by setting the <code>temperMismatchParameter</code> option.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">agm.result =<span class="st"> </span><span class="kw">agm</span>(test.data,test.times,LV_func,<span class="dv">4</span>,<span class="dt">noise.sd=</span><span class="fl">0.1</span>,<span class="dt">temperMismatchParameter=</span><span class="ot">TRUE</span>,
    <span class="dt">originalSignalOnlyPositive=</span><span class="ot">TRUE</span>,
    <span class="dt">logPrior=</span><span class="st">&quot;Gamma&quot;</span>, <span class="dt">defaultTemperingScheme=</span><span class="st">&quot;LB10&quot;</span>)</code></pre></div>
<p>Users can specify their own values for the tempering ladder by ensuring <code>temperMismatchParameter=TRUE</code>, <code>defaultTemperingScheme=FALSE</code> and then passing their matrix of values to <code>mismatchParameterValues</code>. The number of rows of the matrix should be equal to the number of parallel chains and the number of columns should be equal to the number of variables in the system. A typical ladder should have the largest value in the first row and the smallest value in the last row.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">agm.result =<span class="st"> </span><span class="kw">agm</span>(test.data,test.times,LV_func,<span class="dv">4</span>,<span class="dt">noise.sd=</span><span class="fl">0.1</span>,<span class="dt">temperMismatchParameter=</span><span class="ot">TRUE</span>,
    <span class="dt">originalSignalOnlyPositive=</span><span class="ot">TRUE</span>,<span class="dt">logPrior=</span><span class="st">&quot;Gamma&quot;</span>,
    <span class="dt">mismatchParameterValues=</span><span class="kw">matrix</span>(<span class="kw">seq</span>(<span class="fl">0.01</span>,<span class="dv">1</span>,<span class="dt">length.out=</span><span class="dv">20</span>),<span class="dt">nrow=</span><span class="dv">20</span>,<span class="dt">ncol=</span><span class="dv">2</span>))</code></pre></div>
</div>
<div id="parameter-inference-by-explicitly-solving-the-ode-system" class="section level2">
<h2>Parameter inference by explicitly solving the ODE system</h2>
<p>For comparison purposes, we also implemented a version of the MCMC algorithm that explicitly solves the ODE system at each step (with <code>deSolve</code>), rather than using gradient matching. This can be invoked by using the <code>explicit</code> flag.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">agm.result =<span class="st"> </span><span class="kw">agm</span>(test.data,test.times,LV_func,<span class="dt">numberOfParameters=</span><span class="dv">6</span>,<span class="dt">explicit=</span><span class="ot">TRUE</span>)</code></pre></div>
<p>Note that the number of parameters has increased; this is because the initial states of the ODE at the first time point also need to be inferred when using this method. So in the Lotka-Volterra case, the number of parameters increases by 2 because there are 2 variables in the ODE system.</p>
</div>
</div>
<div id="a-slightly-bigger-example" class="section level1">
<h1>A slightly bigger example</h1>
<p>The package can in principle deal with ODE systems of any size, although in practice the achievable size will depend on memory and running time considerations. Here we show how to apply it to an ODE system with five equations and six parameters, derived from <span class="citation">Vyshemirsky and Girolami (2007)</span>.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># Function encoding the Vyshemirsky and Girolami ODE model 1.</span>
VG_func &lt;-<span class="st"> </span>function(t, X, params) {
  MM &lt;-<span class="st"> </span>((params[<span class="dv">5</span>]*X[,<span class="dv">5</span>])/(params[<span class="dv">6</span>]+X[,<span class="dv">5</span>])) <span class="co"># Michaelis-Menten term</span>

  
  dxdt &lt;-<span class="st"> </span><span class="kw">cbind</span>( -<span class="st"> </span>params[<span class="dv">1</span>]*X[,<span class="dv">1</span>] -<span class="st"> </span>params[<span class="dv">2</span>]*X[,<span class="dv">1</span>]*X[,<span class="dv">3</span>] +<span class="st"> </span>
<span class="st">                   </span>params[<span class="dv">3</span>]*X[,<span class="dv">4</span>], <span class="co"># S</span>
                 params[<span class="dv">1</span>]*X[,<span class="dv">1</span>], <span class="co"># dS</span>
                 -<span class="st"> </span>params[<span class="dv">2</span>]*X[,<span class="dv">1</span>]*X[,<span class="dv">3</span>] +<span class="st"> </span>params[<span class="dv">3</span>]*X[,<span class="dv">4</span>] +<span class="st"> </span>
<span class="st">                   </span>MM, <span class="co"># R</span>
                 params[<span class="dv">2</span>]*X[,<span class="dv">1</span>]*X[,<span class="dv">3</span>] -<span class="st"> </span>params[<span class="dv">3</span>]*X[,<span class="dv">4</span>] -<span class="st"> </span>
<span class="st">                   </span>params[<span class="dv">4</span>]*X[,<span class="dv">4</span>], <span class="co"># RS</span>
                 params[<span class="dv">4</span>]*X[,<span class="dv">4</span>] -<span class="st"> </span>MM <span class="co"># Rpp</span>
           )
  
  <span class="kw">return</span>(dxdt)
}

<span class="co"># Generate data</span>
timeTest =<span class="st"> </span><span class="kw">c</span>(<span class="dv">0</span>,<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">4</span>,<span class="dv">5</span>,<span class="dv">7</span>,<span class="dv">10</span>,<span class="dv">15</span>,<span class="dv">20</span>,<span class="dv">30</span>,<span class="dv">40</span>,<span class="dv">50</span>,<span class="dv">60</span>,<span class="dv">80</span>,<span class="dv">100</span>)
dataTest =<span class="st"> </span><span class="kw">ode</span>(<span class="kw">c</span>(<span class="dv">1</span>,<span class="dv">0</span>,<span class="dv">1</span>,<span class="dv">0</span>,<span class="dv">0</span>), timeTest, 
               function(t,y,params) <span class="kw">list</span>(<span class="kw">VG_func</span>(t,<span class="kw">matrix</span>(y,<span class="dv">1</span>,<span class="kw">length</span>(y)),params)), <span class="kw">c</span>(<span class="fl">0.07</span>,<span class="fl">0.6</span>,<span class="fl">0.05</span>,<span class="fl">0.3</span>,<span class="fl">0.017</span>,<span class="fl">0.3</span>))
dataTest =<span class="st"> </span>dataTest[,<span class="dv">2</span>:<span class="dv">6</span>] +<span class="st"> </span><span class="kw">rnorm</span>(<span class="kw">dim</span>(dataTest)[<span class="dv">1</span>]*<span class="dv">5</span>,<span class="dv">0</span>,<span class="fl">0.01</span>)


<span class="co"># Run adaptive gradient matching</span>
agm.result =<span class="st"> </span><span class="kw">agm</span>(<span class="dt">data=</span>dataTest,<span class="dt">time=</span>timeTest,<span class="dt">ode.system=</span>VG_func, <span class="dt">numberOfParameters=</span><span class="dv">6</span>)</code></pre></div>
</div>
<div id="inference-with-unobserved-variables" class="section level1">
<h1>Inference with unobserved variables</h1>
<p>If not all variables are observed, we can infer the unobserved variables by using a latent Gaussian process. Note that the <code>data</code> matrix still needs to have a column for each variable, but unobserved variables can be set to <code>NA</code>, and the observed variables need to be specified in <code>observedVariables</code>. Partially observed variables are not currently supported.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># Remove the observations of the first variable</span>
dataTest[,<span class="dv">1</span>] =<span class="st"> </span><span class="ot">NA</span>

<span class="co"># Run adaptive gradient matching</span>
agm.result =<span class="st"> </span><span class="kw">agm</span>(<span class="dt">data=</span>dataTest,<span class="dt">time=</span>timeTest,<span class="dt">ode.system=</span>VG_func, <span class="dt">observedVariables=</span><span class="dv">2</span>:<span class="dv">5</span>, <span class="dt">numberOfParameters=</span><span class="dv">6</span>)</code></pre></div>
</div>
<div id="references" class="section level1 unnumbered">
<h1>References</h1>
<div id="refs" class="references">
<div id="ref-calderhead2009">
<p> Calderhead, B., Girolami, M., Lawrence, N.D.: Accelerating Bayesian inference over nonlinear differential equations with Gaussian processes. In: Advances in neural information processing systems. pp. 217–224 (2009)</p>
</div>
<div id="ref-dondelinger2013">
<p> Dondelinger, F., Husmeier, D., Rogers, S., Filippone, M.: ODE parameter inference using adaptive gradient matching with Gaussian processes. In: Artificial intelligence and statistics. pp. 216–228 (2013)</p>
</div>
<div id="ref-macdonald2017">
<p> Macdonald, B.: Statistical inference for ordinary differential equations using gradient matching, (2017)</p>
</div>
<div id="ref-vyshemirsky2007">
<p> Vyshemirsky, V., Girolami, M.A.: Bayesian ranking of biochemical system models. Bioinformatics. 24, 833–839 (2007)</p>
</div>
</div>
</div>



<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
